# 多数元素

**难度：** 简单  
**核心技能：** 摩尔投票法 • 计数器

> **题目来源：** [LeetCode 169. 多数元素](https://leetcode.cn/problems/majority-element/)

## 🎯 题目描述

给定一个大小为 `n` 的数组 `nums`，返回其中的多数元素。多数元素是指在数组中出现次数**大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**进阶：** 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。

## 📋 示例演示

### 示例 1：
**输入：** nums = [3,2,3]  
**输出：** 3

### 示例 2：
**输入：** nums = [2,2,1,1,1,2,2]  
**输出：** 2

### 示例 3：
**输入：** nums = [1]  
**输出：** 1

## 💡 解决方案：摩尔投票法（Boyer-Moore Voting Algorithm）

**算法思路：**
- 维护一个候选者（nominee）和一个计数器（counter）
- 遍历数组，如果当前元素与候选者相同，计数器加1；否则计数器减1
- 当计数器为0时，更换候选者为当前元素，并重置计数器为1
- 由于多数元素出现次数大于 n/2，最终的候选者一定是多数元素

**核心优势：**
- 时间复杂度：O(n) - 只需要一次遍历
- 空间复杂度：O(1) - 只使用常数额外空间
- 算法巧妙利用了多数元素的特性：即使被其他元素"抵消"，最终仍会胜出

## 🔍 算法步骤

1. **初始化：** 将第一个元素设为候选者，计数器设为1
2. **遍历数组：** 从第二个元素开始
   - 如果计数器为0，更新候选者为当前元素，计数器重置为1
   - 如果当前元素等于候选者，计数器加1
   - 如果当前元素不等于候选者，计数器减1
3. **返回结果：** 遍历结束后的候选者即为多数元素

## ⚡ 复杂度分析

- **时间复杂度：** O(n) - 需要遍历整个数组一次
- **空间复杂度：** O(1) - 只使用了两个额外变量

## 🎨 算法可视化要点

- **候选者变化：** 展示候选者如何在遍历过程中可能发生变化
- **计数器波动：** 显示计数器如何随着相同/不同元素而增减
- **"投票"过程：** 形象化展示每个元素如何为候选者"投票"或"反对"