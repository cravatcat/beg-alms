# 轮转数组

**难度：** 中等  
**核心技能：** 数组反转 • 三次反转法 • 原地操作

> **题目来源：** [LeetCode 189. 轮转数组](https://leetcode.cn/problems/rotate-array/)

## 🎯 题目描述

给定一个数组，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

**要求：** 使用空间复杂度为 O(1) 的原地算法解决这个问题。

## 📋 示例演示

### 示例 1：
**输入：** nums = [1,2,3,4,5,6,7], k = 3  
**输出：** [5,6,7,1,2,3,4]  
**解释：**
- 向右轮转 1 步: [7,1,2,3,4,5,6]
- 向右轮转 2 步: [6,7,1,2,3,4,5]
- 向右轮转 3 步: [5,6,7,1,2,3,4]

### 示例 2：
**输入：** nums = [-1,-100,3,99], k = 2  
**输出：** [3,99,-1,-100]  
**解释：**
- 向右轮转 1 步: [99,-1,-100,3]
- 向右轮转 2 步: [3,99,-1,-100]

### 示例 3：
**输入：** nums = [1,2], k = 1  
**输出：** [2,1]

## 💡 解决方案：三次反转法

**算法思路：**
- 通过三次数组反转操作来实现轮转效果
- 第一次：反转整个数组
- 第二次：反转前 k 个元素
- 第三次：反转后 n-k 个元素

**核心优势：**
- 时间复杂度：O(n) - 每个元素最多被访问 3 次
- 空间复杂度：O(1) - 原地操作，只使用常数额外空间
- 算法简洁优雅，易于理解和实现

## 🔍 算法步骤

以 nums = [1,2,3,4,5,6,7], k = 3 为例：

1. **处理 k 值：** k = k % nums.length（处理 k 大于数组长度的情况）
2. **第一次反转：** 反转整个数组 [1,2,3,4,5,6,7] → [7,6,5,4,3,2,1]
3. **第二次反转：** 反转前 k 个元素 [7,6,5,4,3,2,1] → [5,6,7,4,3,2,1]
4. **第三次反转：** 反转后 n-k 个元素 [5,6,7,4,3,2,1] → [5,6,7,1,2,3,4]

## 🔧 反转函数实现

```javascript
function reverse(i, j, nums) {
    while (i < j) {
        [nums[i], nums[j - 1]] = [nums[j - 1], nums[i]];
        i++;
        j--;
    }
}
```

**参数说明：**
- `i`：起始索引（包含）
- `j`：结束索引（不包含）
- `nums`：要反转的数组

## ⚡ 复杂度分析

- **时间复杂度：** O(n) - 三次反转操作，每次最多遍历 n 个元素
- **空间复杂度：** O(1) - 原地操作，只使用了常数额外空间

## 🎨 算法可视化要点

- **三步反转过程：** 清晰展示每一步反转操作的效果
- **元素移动轨迹：** 显示每个元素如何从原位置移动到最终位置
- **双指针交换：** 展示反转函数中双指针如何向中间靠拢并交换元素
- **边界处理：** 演示 k 值的模运算处理过程

## 🧠 算法直觉

想象一个圆形队列，向右轮转 k 位相当于：
1. 把整个队列"翻转"过来
2. 把前 k 个位置"翻转"回来
3. 把剩余位置"翻转"回来

这样就巧妙地实现了轮转效果，而且是原地操作！