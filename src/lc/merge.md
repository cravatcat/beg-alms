# 合并两个有序数组

**难度：** 简单  
**核心技能：** 双指针 • 逆向合并

> **题目来源：** [LeetCode 88. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/)

## 🎯 题目描述

给你两个按**非递减顺序**排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n`，分别表示 `nums1` 和 `nums2` 中元素的数量。

请你**合并** `nums2` 到 `nums1` 中，使合并后的数组同样按**非递减顺序**排列。

**注意：** `nums1` 的初始长度为 `m + n`，其中前 `m` 个元素为有效元素，后 `n` 个元素为 `0`（占位符）。
- 最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中
- 为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0`，应忽略
- `nums2` 的长度为 `n`

## 📋 示例演示

### 示例 1：
**输入：** 
- nums1 = [1,2,3,0,0,0], m = 3
- nums2 = [2,5,6], n = 3

**输出：** [1,2,2,3,5,6]  
**解释：** 需要合并 [1,2,3] 和 [2,5,6]，合并的结果是 [1,2,2,3,5,6]

### 示例 2：
**输入：** 
- nums1 = [1], m = 1
- nums2 = [], n = 0

**输出：** [1]  
**解释：** 需要合并 [1] 和 []，合并的结果是 [1]

### 示例 3：
**输入：** 
- nums1 = [0], m = 0
- nums2 = [1], n = 1

**输出：** [1]  
**解释：** 需要合并 [] 和 [1]，合并的结果是 [1]。注意，因为 m = 0，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中

## 💡 解决方案：逆向双指针

**算法思路：**
- 由于 `nums1` 的后半部分是空的，可以直接覆盖而不会影响结果
- 从两个数组的末尾开始比较，每次选择较大的元素放到 `nums1` 的末尾
- 这样可以避免元素覆盖问题，实现原地合并